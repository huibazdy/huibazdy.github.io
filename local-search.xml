<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>虚拟内存（一）</title>
    <link href="/2023/04/02/VirtualMemory1/"/>
    <url>/2023/04/02/VirtualMemory1/</url>
    
    <content type="html"><![CDATA[<h1 id="一、虚拟内存"><a href="#一、虚拟内存" class="headerlink" title="一、虚拟内存"></a>一、虚拟内存</h1><p><strong>虚拟内存</strong>（<strong>Virtual Memory，VM</strong>）是一个被组织在磁盘上的 <strong>N</strong> 个连续字节单元组成的的数组。每个字节单元由唯一的<strong>虚拟地址</strong>（<strong>Virtual Address，VA</strong>）作为索引。</p><h1 id="二、地址空间"><a href="#二、地址空间" class="headerlink" title="二、地址空间"></a>二、地址空间</h1><h2 id="2-1-物理地址空间"><a href="#2-1-物理地址空间" class="headerlink" title="2.1 物理地址空间"></a>2.1 物理地址空间</h2><p><strong>物理地址空间</strong>（<strong>Physical Address Space，PAS</strong>）可以理解为物理内存中的连续字节单元的地址集合。设物理内存共有 <strong>M</strong> 个字节单元，为简化讨论，假定 <strong>M &#x3D; 2<sup>m</sup><strong>（实际情况不要求 <strong>M</strong> 是 <strong>2</strong> 的幂），</strong>M</strong> 表示一个 <strong>m</strong> 位的物理地址空间。</p><h2 id="2-2-虚拟地址空间"><a href="#2-2-虚拟地址空间" class="headerlink" title="2.2 虚拟地址空间"></a>2.2 虚拟地址空间</h2><p><strong>虚拟地址空间</strong>（<strong>Virtual Address Space，VAS</strong>）实际上是仿照物理内存虚拟出来的一个连续字节单元的地址集合，由表示最大地址所需位数来描述。例如一个 <strong>n</strong> 位 <strong>VAS</strong>，包含 <strong>N &#x3D; 2<sup>n</sup></strong> 个地址。现代操作系统一般支持 <strong>32</strong> 位或 <strong>64</strong> 位 <strong>VAS</strong>。</p><h1 id="三、页"><a href="#三、页" class="headerlink" title="三、页"></a>三、页</h1><p>虚拟内存是为了解决物理内存不足的问题。为了实现将磁盘上的存储空间虚拟化为内存，并由操作系统一管理，必须使用相同大小的数据传输单元（或者说数据块），来实现物理内存与虚拟内存之间的数据交换。这些大小固定的数据块被称为<strong>页（page）</strong>。</p><h2 id="3-1-虚拟页"><a href="#3-1-虚拟页" class="headerlink" title="3.1 虚拟页"></a>3.1 虚拟页</h2><p>在磁盘上的虚拟内存系统将这些数据块称为<strong>虚拟页（Virtual Page，VP）</strong>。每个 <strong>VP</strong> 的大小为 <strong>P</strong> 个字节，<strong>P &#x3D; 2<sup>p</sup></strong> ，一般 P 的大小为：<strong>4 KB ~ 2 MB</strong>。</p><p><strong>VP</strong> 可以划分为三个互斥子集：1）<strong>未分配页</strong>，即与任何数据无关联，可以理解为页内无数据的虚拟页；2）<strong>未缓存页</strong>，即已在页内分配数据但还未缓存在内存中的虚拟页；3）<strong>已缓存页</strong>，即已在页内分配数据且被缓存在内存中的虚拟页。</p><h2 id="3-2-物理页"><a href="#3-2-物理页" class="headerlink" title="3.2 物理页"></a>3.2 物理页</h2><p>物理内存也被分割为同样大小的块，每个块也是 <strong>P</strong> 字节，这些块称为<strong>物理页</strong>（<strong>Physical Page，PP</strong>），物理页也被称为<strong>页帧</strong>（<strong>Page Frame</strong>）。</p><h1 id="四、页表"><a href="#四、页表" class="headerlink" title="四、页表"></a>四、页表</h1><p>我们最终的目的是利用 <strong>VM</strong> 将需要处理的数据从磁盘中取出，并送入内存中，从而达到高效使用内存的目的。</p><p>为此，我们需要在内存中维护一个数据结构来记录和查询 <strong>VP</strong> 的状态，包括一个 <strong>VP</strong> 是否已缓存到内存中；若已缓存，还需要知道这个 <strong>VP</strong> 放在哪个 <strong>PP</strong> 中等信息。这个数据结构称为<strong>页表（Page Table，PT）</strong>。</p><h2 id="4-1-页表条目"><a href="#4-1-页表条目" class="headerlink" title="4.1 页表条目"></a>4.1 页表条目</h2><p>每个 <strong>VP</strong> 的状态信息称为一个<strong>页表条目（Page Table Entry，PTE）</strong>，因此 <strong>PT</strong> 也可以看作是以 <strong>PTE</strong> 作为元素的数组。</p><p><strong>PTE</strong> 分为两个部分，一部分是<strong>有效位</strong>，另一部分是<strong>地址字段</strong>。</p><p>有效位用于标记该 <strong>VP</strong> 是否缓存在物理内存中，置 <strong>1</strong> 表明已缓存，置 <strong>0</strong> 表示未缓存。若置 <strong>1</strong>，地址字段就是缓存了该 <strong>VP</strong> 的 <strong>PP</strong> 的起始地址。若置 <strong>0</strong>，则分为该 <strong>VP</strong> 是否已分配两种情况：第一种是未分配，地址字段此时为空地址；第二种情况是已分配，地址字段为该 <strong>VP</strong> 在磁盘中的起始位置。PTE 结构示意图如下：</p><div align = "center"> <img src="/2023/04/02/VirtualMemory1/1.png" class=""></div><h2 id="4-2-页表工作机制"><a href="#4-2-页表工作机制" class="headerlink" title="4.2 页表工作机制"></a>4.2 页表工作机制</h2><p>页表的典型工作流程：</p><ol><li>CPU 生成一个虚拟地址，并将其传给 MMU ；</li><li>MMU 生成<strong>页表条目地址（PTEA</strong>），并从高速缓存&#x2F;内存请求得到它；</li><li>高速缓存&#x2F;内存返回 PTE 的内容给 MMU ；</li><li>MMU 根据返回的 PTE 构造<strong>物理地址（PA）</strong>，并将 PA 传给高速缓存&#x2F;内存；</li><li>高速缓存&#x2F;内存返回 PA 对应的数据字给 CPU 。</li></ol><p>工作流程图如下：</p><div align = "center"> <img src="/2023/04/02/VirtualMemory1/2.png" class=""></div>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>虚拟内存</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>重建二叉树</title>
    <link href="/2023/03/25/%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2023/03/25/%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h1><p>根据树的前序、中序遍历结果，重建二叉树，并返回二叉树的根结点。</p><h1 id="二、实例"><a href="#二、实例" class="headerlink" title="二、实例"></a>二、实例</h1><p>【输入】前序遍历序列：{1, 2, 4, 7, 3, 5, 6, 8}；中序遍历序列：{4, 7, 2, 1, 5, 3, 8, 6}</p><p>【输出】</p><div align = "center"> <img src="/2023/03/25/%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/1.png" class=""></div><h1 id="三、问题分析"><a href="#三、问题分析" class="headerlink" title="三、问题分析"></a>三、问题分析</h1><ol><li><p>根据前序遍历的顺序（根左右），可以很容易从前序遍历序列中得出，首元素 <strong>1</strong> 即为整棵树的根节点，或者说是第一层的节点：</p> <div align = "center"><img src="/2023/03/25/%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/2.png" class=""></div></li><li><p>根据中序遍历的顺序（左根右），结合上一步得出的根节点，可以用根节点 <strong>1</strong> 划分中序遍历序列，从而得到左右子树：</p> <div align = "center"><img src="/2023/03/25/%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/3.png" class=""></div></li><li><p>重复步骤 1，根据步骤 2 中得到的左右子树序列，可以在前序序列中标出，并且找到左右子树的根节点（首元素），分别是 <strong>2</strong> 和 <strong>5</strong>，这两个元素也是第二层的两个节点值：</p> <div align = "center"><img src="/2023/03/25/%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/4.png" class=""></div></li><li><p>重复步骤 2，用步骤 3 中得到的根节点 <strong>2</strong> 和 <strong>5</strong> 划分中序遍历序列，可以分别得到这两个节点的左右子树序列：</p> <div align = "center"><img src="/2023/03/25/%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/5.png" class=""></div></li><li><p>重复步骤 1，根据步骤 4 中得到的左右子树序列，在前序序列中找到这些子树分别对应的根结点，这些根结点分别为：<strong>4</strong>，<strong>5</strong>，<strong>6</strong>：</p> <div align = "center"><img src="/2023/03/25/%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/6.png" class=""></div></li><li><p>重复步骤2，根据步骤 5 中得到的根节点（<strong>4</strong>，<strong>5</strong>，<strong>6</strong>）划分中序遍历序列，得到这些节点的子树序列（4 的右子树为 7，6 的左子树为 8）：</p> <div align = "center"><img src="/2023/03/25/%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/7.png" class=""></div></li></ol><h1 id="四、代码实现"><a href="#四、代码实现" class="headerlink" title="四、代码实现"></a>四、代码实现</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;BinaryTree.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;exception&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><br><span class="hljs-function">BinaryTreeNode* <span class="hljs-title">ConstructCore</span><span class="hljs-params">(<span class="hljs-type">int</span>* startPreorder, <span class="hljs-type">int</span>* endPreorder, <span class="hljs-type">int</span>* startInorder, <span class="hljs-type">int</span>* endInorder)</span></span>;<br><br><span class="hljs-function">BinaryTreeNode* <span class="hljs-title">Construct</span><span class="hljs-params">(<span class="hljs-type">int</span>* preorder, <span class="hljs-type">int</span>* inorder, <span class="hljs-type">int</span> length)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(preorder == <span class="hljs-literal">nullptr</span> || inorder == <span class="hljs-literal">nullptr</span> || length &lt;= <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">ConstructCore</span>(preorder, preorder + length - <span class="hljs-number">1</span>,<br>        inorder, inorder + length - <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-function">BinaryTreeNode* <span class="hljs-title">ConstructCore</span></span><br><span class="hljs-function"><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">int</span>* startPreorder, <span class="hljs-type">int</span>* endPreorder, </span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">int</span>* startInorder, <span class="hljs-type">int</span>* endInorder</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 前序遍历序列的第一个数字是根结点的值</span><br>    <span class="hljs-type">int</span> rootValue = startPreorder[<span class="hljs-number">0</span>];<br>    BinaryTreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">BinaryTreeNode</span>();<br>    root-&gt;m_nValue = rootValue;<br>    root-&gt;m_pLeft = root-&gt;m_pRight = <span class="hljs-literal">nullptr</span>;<br><br>    <span class="hljs-keyword">if</span>(startPreorder == endPreorder)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(startInorder == endInorder &amp;&amp; *startPreorder == *startInorder)<br>            <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">exception</span>(<span class="hljs-string">&quot;Invalid input.&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 在中序遍历中找到根结点的值</span><br>    <span class="hljs-type">int</span>* rootInorder = startInorder;<br>    <span class="hljs-keyword">while</span>(rootInorder &lt;= endInorder &amp;&amp; *rootInorder != rootValue)<br>        ++ rootInorder;<br><br>    <span class="hljs-keyword">if</span>(rootInorder == endInorder &amp;&amp; *rootInorder != rootValue)<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">exception</span>(<span class="hljs-string">&quot;Invalid input.&quot;</span>);<br><br>    <span class="hljs-type">int</span> leftLength = rootInorder - startInorder;<br>    <span class="hljs-type">int</span>* leftPreorderEnd = startPreorder + leftLength;<br>    <span class="hljs-keyword">if</span>(leftLength &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-comment">// 构建左子树</span><br>        root-&gt;m_pLeft = <span class="hljs-built_in">ConstructCore</span>(startPreorder + <span class="hljs-number">1</span>, leftPreorderEnd, <br>            startInorder, rootInorder - <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(leftLength &lt; endPreorder - startPreorder)<br>    &#123;<br>        <span class="hljs-comment">// 构建右子树</span><br>        root-&gt;m_pRight = <span class="hljs-built_in">ConstructCore</span>(leftPreorderEnd + <span class="hljs-number">1</span>, endPreorder,<br>            rootInorder + <span class="hljs-number">1</span>, endInorder);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
