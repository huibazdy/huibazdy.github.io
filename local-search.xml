<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>重建二叉树</title>
    <link href="/2023/03/25/%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2023/03/25/%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h1><p>根据树的前序、中序遍历结果，重建二叉树，并返回二叉树的根结点。</p><h1 id="二、实例"><a href="#二、实例" class="headerlink" title="二、实例"></a>二、实例</h1><p>【输入】前序遍历序列：{1, 2, 4, 7, 3, 5, 6, 8}；中序遍历序列：{4, 7, 2, 1, 5, 3, 8, 6}</p><p>【输出】</p><div align = "center"> <img src="/2023/03/25/%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/1.png" class=""></div><h1 id="三、问题分析"><a href="#三、问题分析" class="headerlink" title="三、问题分析"></a>三、问题分析</h1><ol><li><p>根据前序遍历的顺序（根左右），可以很容易从前序遍历序列中得出，首元素 <strong>1</strong> 即为整棵树的根节点，或者说是第一层的节点：</p> <div align = "center"><img src="/2023/03/25/%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/2.png" class=""></div></li><li><p>根据中序遍历的顺序（左根右），结合上一步得出的根节点，可以用根节点 <strong>1</strong> 划分中序遍历序列，从而得到左右子树：</p> <div align = "center"><img src="/2023/03/25/%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/3.png" class=""></div></li><li><p>重复步骤 1，根据步骤 2 中得到的左右子树序列，可以在前序序列中标出，并且找到左右子树的根节点（首元素），分别是 <strong>2</strong> 和 <strong>5</strong>，这两个元素也是第二层的两个节点值：</p> <div align = "center"><img src="/2023/03/25/%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/4.png" class=""></div></li><li><p>重复步骤 2，用步骤 3 中得到的根节点 <strong>2</strong> 和 <strong>5</strong> 划分中序遍历序列，可以分别得到这两个节点的左右子树序列：</p> <div align = "center"><img src="/2023/03/25/%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/5.png" class=""></div></li><li><p>重复步骤 1，根据步骤 4 中得到的左右子树序列，在前序序列中找到这些子树分别对应的根结点，这些根结点分别为：<strong>4</strong>，<strong>5</strong>，<strong>6</strong>：</p> <div align = "center"><img src="/2023/03/25/%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/6.png" class=""></div></li><li><p>重复步骤2，根据步骤 5 中得到的根节点（<strong>4</strong>，<strong>5</strong>，<strong>6</strong>）划分中序遍历序列，得到这些节点的子树序列（4 的右子树为 7，6 的左子树为 8）：</p> <div align = "center"><img src="/2023/03/25/%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/7.png" class=""></div></li></ol><h1 id="四、代码实现"><a href="#四、代码实现" class="headerlink" title="四、代码实现"></a>四、代码实现</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;BinaryTree.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;exception&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><br><span class="hljs-function">BinaryTreeNode* <span class="hljs-title">ConstructCore</span><span class="hljs-params">(<span class="hljs-type">int</span>* startPreorder, <span class="hljs-type">int</span>* endPreorder, <span class="hljs-type">int</span>* startInorder, <span class="hljs-type">int</span>* endInorder)</span></span>;<br><br><span class="hljs-function">BinaryTreeNode* <span class="hljs-title">Construct</span><span class="hljs-params">(<span class="hljs-type">int</span>* preorder, <span class="hljs-type">int</span>* inorder, <span class="hljs-type">int</span> length)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(preorder == <span class="hljs-literal">nullptr</span> || inorder == <span class="hljs-literal">nullptr</span> || length &lt;= <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">ConstructCore</span>(preorder, preorder + length - <span class="hljs-number">1</span>,<br>        inorder, inorder + length - <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-function">BinaryTreeNode* <span class="hljs-title">ConstructCore</span></span><br><span class="hljs-function"><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">int</span>* startPreorder, <span class="hljs-type">int</span>* endPreorder, </span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">int</span>* startInorder, <span class="hljs-type">int</span>* endInorder</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 前序遍历序列的第一个数字是根结点的值</span><br>    <span class="hljs-type">int</span> rootValue = startPreorder[<span class="hljs-number">0</span>];<br>    BinaryTreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">BinaryTreeNode</span>();<br>    root-&gt;m_nValue = rootValue;<br>    root-&gt;m_pLeft = root-&gt;m_pRight = <span class="hljs-literal">nullptr</span>;<br><br>    <span class="hljs-keyword">if</span>(startPreorder == endPreorder)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(startInorder == endInorder &amp;&amp; *startPreorder == *startInorder)<br>            <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">exception</span>(<span class="hljs-string">&quot;Invalid input.&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 在中序遍历中找到根结点的值</span><br>    <span class="hljs-type">int</span>* rootInorder = startInorder;<br>    <span class="hljs-keyword">while</span>(rootInorder &lt;= endInorder &amp;&amp; *rootInorder != rootValue)<br>        ++ rootInorder;<br><br>    <span class="hljs-keyword">if</span>(rootInorder == endInorder &amp;&amp; *rootInorder != rootValue)<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">exception</span>(<span class="hljs-string">&quot;Invalid input.&quot;</span>);<br><br>    <span class="hljs-type">int</span> leftLength = rootInorder - startInorder;<br>    <span class="hljs-type">int</span>* leftPreorderEnd = startPreorder + leftLength;<br>    <span class="hljs-keyword">if</span>(leftLength &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-comment">// 构建左子树</span><br>        root-&gt;m_pLeft = <span class="hljs-built_in">ConstructCore</span>(startPreorder + <span class="hljs-number">1</span>, leftPreorderEnd, <br>            startInorder, rootInorder - <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(leftLength &lt; endPreorder - startPreorder)<br>    &#123;<br>        <span class="hljs-comment">// 构建右子树</span><br>        root-&gt;m_pRight = <span class="hljs-built_in">ConstructCore</span>(leftPreorderEnd + <span class="hljs-number">1</span>, endPreorder,<br>            rootInorder + <span class="hljs-number">1</span>, endInorder);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
